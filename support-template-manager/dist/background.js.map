{"version":3,"file":"background.js","mappings":";;;;;;;;;;;;;;;;;AAAA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACO;AACA;AACA;AACP;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA,sCAAsC,0BAA0B;AAChE;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mBAAmB,sBAAsB,cAAc;AACpG;AACA,0DAA0D,eAAe,iFAAiF;AAC1J;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,UAAU,sBAAsB,kBAAkB;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,kBAAkB,sBAAsB,sBAAsB;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,iCAAiC,yCAAyC;AACtJ;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA,iEAAiE,mBAAmB,qHAAqH;AACzM;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,sCAAsC,mCAAmC;AACzE;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,KAAK;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,uGAAuG,eAAe;AACtH,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,KAAK;AAC5C;AACA,qDAAqD,eAAe;AACpE,kBAAkB;AAClB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,iEAAe,cAAc,EAAC;;;;;;;UClQ9B;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;ACNA;AACiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,cAAc,2GAA2G,aAAa,qEAAqE,eAAe,gCAAgC,WAAW,MAAM,WAAW;AACxT;AACA,sBAAsB,yEAAyE;AAC/F,sBAAsB,+EAA+E;AACrG,sBAAsB,iFAAiF;AACvG,sBAAsB,+DAA+D;AACrF,sBAAsB,sEAAsE;AAC5F;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,qCAAqC,cAAc,0DAA0D,SAAS,6KAA6K,cAAc,iFAAiF,qBAAqB,wIAAwI,WAAW,MAAM,aAAa;AAC7jB;AACA,sBAAsB,yEAAyE;AAC/F,sBAAsB,sEAAsE;AAC5F,sBAAsB,+EAA+E;AACrG,sBAAsB,uIAAuI;AAC7J,sBAAsB,+DAA+D;AACrF,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,kCAAkC,cAAc,yEAAyE,kBAAkB,kRAAkR,WAAW,MAAM,WAAW;AACzb;AACA,sBAAsB,yEAAyE;AAC/F,sBAAsB,2FAA2F;AACjH,sBAAsB,+DAA+D;AACrF,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,cAAc,uEAAuE,kBAAkB,0IAA0I,eAAe,wHAAwH,WAAW,cAAc,WAAW;AACzc;AACA,sBAAsB,yEAAyE;AAC/F,sBAAsB,8EAA8E;AACpG,sBAAsB,iFAAiF;AACvG,sBAAsB,+DAA+D;AACrF,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,kCAAkC,CAAC,0DAAW,qBAAqB;AACnE;AACA,SAAS;AACT;AACA;AACA;AACA,gCAAgC,0DAAW;AAC3C,qCAAqC,0DAAW;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,KAAK;AACpD;AACA,6DAA6D,QAAQ;AACrE,0BAA0B;AAC1B;AACA;AACA,iBAAiB;AACjB,0CAA0C,CAAC,0DAAW,sBAAsB;AAC5E;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","sources":["webpack://support-template-manager/./src/services/storage.ts","webpack://support-template-manager/webpack/bootstrap","webpack://support-template-manager/webpack/runtime/define property getters","webpack://support-template-manager/webpack/runtime/hasOwnProperty shorthand","webpack://support-template-manager/webpack/runtime/make namespace object","webpack://support-template-manager/./src/background.ts"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nexport const STORAGE_KEY = 'support_templates';\nexport const GLOBAL_VARIABLES_KEY = 'support_global_variables';\nexport const storageService = {\n    // Get all templates\n    getTemplates: () => {\n        return new Promise((resolve) => {\n            chrome.storage.sync.get(STORAGE_KEY, (result) => {\n                resolve(result[STORAGE_KEY] || []);\n            });\n        });\n    },\n    // Get template groups (templates organized by baseId)\n    getTemplateGroups: () => __awaiter(void 0, void 0, void 0, function* () {\n        const templates = yield storageService.getTemplates();\n        const groupsMap = {};\n        // Group templates by baseId\n        templates.forEach(template => {\n            const baseId = template.baseId || template.id;\n            if (!groupsMap[baseId]) {\n                groupsMap[baseId] = {\n                    baseId,\n                    name: template.name,\n                    category: template.category,\n                    templates: {\n                        'EN': null,\n                        'FR': null,\n                        'DE': null\n                    },\n                    variables: template.variables\n                };\n            }\n            // Add the template to its language slot\n            const language = template.language || 'EN';\n            groupsMap[baseId].templates[language] = template;\n        });\n        return Object.values(groupsMap);\n    }),\n    // Save templates\n    saveTemplates: (templates) => {\n        return new Promise((resolve) => {\n            chrome.storage.sync.set({ [STORAGE_KEY]: templates }, () => {\n                resolve();\n            });\n        });\n    },\n    // Add new template\n    addTemplate: (template) => __awaiter(void 0, void 0, void 0, function* () {\n        const templates = yield storageService.getTemplates();\n        const timestamp = Date.now();\n        const newId = crypto.randomUUID();\n        // Check if this is a new template or a translation\n        // We'll determine if it's a translation by checking if a template with the same name already exists\n        const existingTemplate = templates.find(t => t.name === template.name);\n        const baseId = existingTemplate ? existingTemplate.baseId : newId;\n        // Check if a template with this language already exists\n        const duplicateLanguage = templates.find(t => t.baseId === baseId &&\n            t.language === template.language);\n        if (duplicateLanguage) {\n            throw new Error(`A template in ${template.language} already exists for \"${template.name}\"`);\n        }\n        const newTemplate = Object.assign(Object.assign({}, template), { id: newId, baseId, isRichText: true, createdAt: timestamp, updatedAt: timestamp });\n        yield storageService.saveTemplates([...templates, newTemplate]);\n        return newTemplate;\n    }),\n    // Add a translation to an existing template\n    addTranslation: (baseTemplate, language, content, isRichText // Keep parameter for backward compatibility\n    ) => __awaiter(void 0, void 0, void 0, function* () {\n        const templates = yield storageService.getTemplates();\n        const timestamp = Date.now();\n        // Check if a translation in this language already exists\n        const existingTranslation = templates.find(t => t.baseId === baseTemplate.baseId &&\n            t.language === language);\n        if (existingTranslation) {\n            throw new Error(`A translation in ${language} already exists for \"${baseTemplate.name}\"`);\n        }\n        const newTranslation = {\n            id: crypto.randomUUID(),\n            baseId: baseTemplate.baseId,\n            name: baseTemplate.name,\n            category: baseTemplate.category,\n            content,\n            variables: baseTemplate.variables,\n            language,\n            isRichText: true, // Always true\n            createdAt: timestamp,\n            updatedAt: timestamp\n        };\n        yield storageService.saveTemplates([...templates, newTranslation]);\n        return newTranslation;\n    }),\n    // Update existing template\n    updateTemplate: (id, updates) => __awaiter(void 0, void 0, void 0, function* () {\n        const templates = yield storageService.getTemplates();\n        const index = templates.findIndex(t => t.id === id);\n        if (index === -1)\n            return null;\n        const templateToUpdate = templates[index];\n        // If changing the language, check if there's already a template in that language\n        if (updates.language && updates.language !== templateToUpdate.language) {\n            const duplicateLanguage = templates.find(t => t.baseId === templateToUpdate.baseId &&\n                t.language === updates.language &&\n                t.id !== id);\n            if (duplicateLanguage) {\n                throw new Error(`A template in ${updates.language} already exists for \"${templateToUpdate.name}\"`);\n            }\n        }\n        // Override isRichText to always be true\n        if (updates.isRichText !== undefined) {\n            updates.isRichText = true;\n        }\n        const updatedTemplate = Object.assign(Object.assign(Object.assign({}, templateToUpdate), updates), { isRichText: true, updatedAt: Date.now() });\n        templates[index] = updatedTemplate;\n        // If name or category is updated, update all templates with the same baseId\n        if (updates.name || updates.category) {\n            for (let i = 0; i < templates.length; i++) {\n                if (templates[i].baseId === templateToUpdate.baseId && i !== index) {\n                    templates[i] = Object.assign(Object.assign({}, templates[i]), { name: updates.name || templates[i].name, category: updates.category || templates[i].category, updatedAt: Date.now() });\n                }\n            }\n        }\n        yield storageService.saveTemplates(templates);\n        return updatedTemplate;\n    }),\n    // Delete template\n    deleteTemplate: (id) => __awaiter(void 0, void 0, void 0, function* () {\n        const templates = yield storageService.getTemplates();\n        const filteredTemplates = templates.filter(t => t.id !== id);\n        if (filteredTemplates.length === templates.length)\n            return false;\n        yield storageService.saveTemplates(filteredTemplates);\n        return true;\n    }),\n    // Delete all templates with the same baseId\n    deleteTemplateGroup: (baseId) => __awaiter(void 0, void 0, void 0, function* () {\n        const templates = yield storageService.getTemplates();\n        const filteredTemplates = templates.filter(t => t.baseId !== baseId);\n        if (filteredTemplates.length === templates.length)\n            return false;\n        yield storageService.saveTemplates(filteredTemplates);\n        return true;\n    }),\n    // Get global variables\n    getGlobalVariables: () => {\n        return new Promise((resolve) => {\n            chrome.storage.sync.get(GLOBAL_VARIABLES_KEY, (result) => {\n                resolve(result[GLOBAL_VARIABLES_KEY] || []);\n            });\n        });\n    },\n    // Save global variables\n    saveGlobalVariables: (variables) => {\n        return new Promise((resolve) => {\n            chrome.storage.sync.set({ [GLOBAL_VARIABLES_KEY]: variables }, () => {\n                resolve();\n            });\n        });\n    },\n    // Update a global variable\n    updateGlobalVariable: (name, updates) => __awaiter(void 0, void 0, void 0, function* () {\n        const variables = yield storageService.getGlobalVariables();\n        const index = variables.findIndex(v => v.name === name);\n        if (index === -1) {\n            // If variable doesn't exist, add it\n            const newVariable = {\n                name,\n                description: updates.description || `Value for ${name}`,\n                defaultValue: updates.defaultValue || ''\n            };\n            yield storageService.saveGlobalVariables([...variables, newVariable]);\n            return newVariable;\n        }\n        // Update existing variable\n        const updatedVariable = Object.assign(Object.assign({}, variables[index]), updates);\n        variables[index] = updatedVariable;\n        yield storageService.saveGlobalVariables(variables);\n        return updatedVariable;\n    }),\n    // Export all data (templates and global variables)\n    exportData: () => __awaiter(void 0, void 0, void 0, function* () {\n        const [templates, globalVariables] = yield Promise.all([\n            storageService.getTemplates(),\n            storageService.getGlobalVariables()\n        ]);\n        return {\n            templates,\n            globalVariables\n        };\n    }),\n    // Import data (templates and global variables)\n    importData: (data) => __awaiter(void 0, void 0, void 0, function* () {\n        if (data.templates) {\n            // Make sure all templates have a baseId and isRichText property (for backwards compatibility)\n            const templatesWithUpdates = data.templates.map(template => (Object.assign(Object.assign({}, template), { baseId: template.baseId || template.id, isRichText: true // Always true\n             })));\n            yield storageService.saveTemplates(templatesWithUpdates);\n        }\n        if (data.globalVariables) {\n            yield storageService.saveGlobalVariables(data.globalVariables);\n        }\n    }),\n    // Migrate existing templates to the new structure with baseId and isRichText\n    migrateTemplates: () => __awaiter(void 0, void 0, void 0, function* () {\n        const templates = yield storageService.getTemplates();\n        let needsMigration = false;\n        // Check if any template is missing a baseId or isRichText property\n        const migratedTemplates = templates.map(template => {\n            const updates = {};\n            if (!template.baseId) {\n                updates.baseId = template.id;\n                needsMigration = true;\n            }\n            if (template.isRichText !== true) {\n                updates.isRichText = true;\n                needsMigration = true;\n            }\n            if (Object.keys(updates).length > 0) {\n                return Object.assign(Object.assign({}, template), updates);\n            }\n            return template;\n        });\n        if (needsMigration) {\n            yield storageService.saveTemplates(migratedTemplates);\n        }\n    }),\n    // Migrate templates to rich text format\n    migrateToRichText: () => __awaiter(void 0, void 0, void 0, function* () {\n        const templates = yield storageService.getTemplates();\n        let needsMigration = false;\n        // Convert all templates to rich text\n        const migratedTemplates = templates.map(template => {\n            if (template.isRichText !== true) {\n                needsMigration = true;\n                // Convert plain text content to HTML\n                const htmlContent = template.content\n                    .split('\\n')\n                    .filter(line => line.trim() !== '') // Skip empty lines\n                    .map(line => `<p>${line}</p>`)\n                    .join('');\n                return Object.assign(Object.assign({}, template), { isRichText: true, content: htmlContent || '<p></p>' // Ensure there's at least an empty paragraph\n                 });\n            }\n            return template;\n        });\n        if (needsMigration) {\n            yield storageService.saveTemplates(migratedTemplates);\n            console.log('Migrated all templates to rich text format');\n        }\n    })\n};\nexport default storageService;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// Background script for our Chrome extension\nimport { STORAGE_KEY } from './services/storage';\n// Listen for installation\nchrome.runtime.onInstalled.addListener((details) => {\n    if (details.reason === 'install') {\n        // Set up initial template examples - all with isRichText=true\n        const initialTemplates = [\n            {\n                id: crypto.randomUUID(),\n                baseId: crypto.randomUUID(),\n                name: 'Welcome Response',\n                category: 'General',\n                content: '<p>Hi {{customerName}},</p><p>Thank you for reaching out to our support team! We\\'re happy to help you with your inquiry about {{productName}}.</p><p>I\\'ll look into this right away and get back to you within {{responseTime}} hours.</p><p>Best regards,<br>{{agentName}}<br>{{teamName}} Support</p>',\n                variables: [\n                    { name: 'customerName', description: 'Customer\\'s name', defaultValue: '' },\n                    { name: 'productName', description: 'Product name', defaultValue: 'our product' },\n                    { name: 'responseTime', description: 'Response time in hours', defaultValue: '24' },\n                    { name: 'agentName', description: 'Your name', defaultValue: '' },\n                    { name: 'teamName', description: 'Team name', defaultValue: 'Customer' },\n                ],\n                language: 'EN',\n                isRichText: true,\n                createdAt: Date.now(),\n                updatedAt: Date.now()\n            },\n            {\n                id: crypto.randomUUID(),\n                baseId: crypto.randomUUID(),\n                name: 'Technical Issue Response',\n                category: 'Technical',\n                content: '<p>Hello {{customerName}},</p><p>I understand you\\'re experiencing an issue with {{feature}}. I apologize for any inconvenience this has caused.</p><p>To help troubleshoot this issue, could you please provide the following information:</p><ol><li>What version of {{productName}} are you currently using?</li><li>When did you first notice this issue?</li><li>{{additionalQuestions}}</li></ol><p>Once I have this information, I\\'ll be better equipped to help resolve your issue.</p><p>Thank you for your patience,<br>{{agentName}}<br>{{department}} Support Team</p>',\n                variables: [\n                    { name: 'customerName', description: 'Customer\\'s name', defaultValue: '' },\n                    { name: 'feature', description: 'Feature with issue', defaultValue: '' },\n                    { name: 'productName', description: 'Product name', defaultValue: 'our product' },\n                    { name: 'additionalQuestions', description: 'Any additional questions', defaultValue: 'Have you tried clearing your cache and cookies?' },\n                    { name: 'agentName', description: 'Your name', defaultValue: '' },\n                    { name: 'department', description: 'Your department', defaultValue: 'Technical' }\n                ],\n                language: 'EN',\n                isRichText: true,\n                createdAt: Date.now(),\n                updatedAt: Date.now()\n            },\n            {\n                id: crypto.randomUUID(),\n                baseId: crypto.randomUUID(),\n                name: 'Follow-up Template',\n                category: 'General',\n                content: '<p>Hi {{customerName}},</p><p>I wanted to follow up on your recent support request regarding {{issueDescription}}.</p><p>Has the solution we provided resolved your issue? If you\\'re still experiencing problems or have any questions, please don\\'t hesitate to let me know.</p><p>Your feedback is important to us as we strive to provide the best possible support.</p><p>Best regards,<br>{{agentName}}<br>{{teamName}} Support</p>',\n                variables: [\n                    { name: 'customerName', description: 'Customer\\'s name', defaultValue: '' },\n                    { name: 'issueDescription', description: 'Brief description of the issue', defaultValue: '' },\n                    { name: 'agentName', description: 'Your name', defaultValue: '' },\n                    { name: 'teamName', description: 'Team name', defaultValue: 'Customer' }\n                ],\n                language: 'EN',\n                isRichText: true,\n                createdAt: Date.now(),\n                updatedAt: Date.now()\n            },\n            // Rich text example template\n            {\n                id: crypto.randomUUID(),\n                baseId: crypto.randomUUID(),\n                name: 'Rich Text Example',\n                category: 'Examples',\n                content: '<p>Hello <strong>{{customerName}}</strong>,</p><p>Thank you for contacting our support team about <em>{{issueDescription}}</em>.</p><ul><li>We have received your request</li><li>A support agent will review it shortly</li><li>You can expect a response within {{responseTime}} hours</li></ul><p>If you have any additional information to share, please reply to this email.</p><p>Best regards,<br>{{agentName}}<br><strong>{{teamName}} Support</strong></p>',\n                variables: [\n                    { name: 'customerName', description: 'Customer\\'s name', defaultValue: '' },\n                    { name: 'issueDescription', description: 'Issue description', defaultValue: '' },\n                    { name: 'responseTime', description: 'Response time in hours', defaultValue: '24' },\n                    { name: 'agentName', description: 'Your name', defaultValue: '' },\n                    { name: 'teamName', description: 'Team name', defaultValue: 'Customer' }\n                ],\n                language: 'EN',\n                isRichText: true,\n                createdAt: Date.now(),\n                updatedAt: Date.now()\n            }\n        ];\n        // For each template, set the baseId to be the same as the id initially\n        initialTemplates.forEach(template => {\n            template.baseId = template.id;\n        });\n        // Save initial templates to storage\n        chrome.storage.sync.set({ [STORAGE_KEY]: initialTemplates }, () => {\n            console.log('Initial templates created');\n        });\n    }\n    else if (details.reason === 'update') {\n        // Migrate all templates to rich text format\n        chrome.storage.sync.get(STORAGE_KEY, (result) => {\n            const templates = result[STORAGE_KEY] || [];\n            // Check if any templates need migration\n            const needsMigration = templates.some((t) => t.isRichText !== true);\n            if (needsMigration) {\n                // Convert any plain text templates to rich text\n                const migratedTemplates = templates.map((t) => {\n                    if (t.isRichText !== true) {\n                        // Convert plain text to basic HTML by wrapping lines in <p> tags\n                        const htmlContent = t.content\n                            .split('\\n')\n                            .filter(line => line.trim() !== '') // Skip empty lines\n                            .map(line => `<p>${line}</p>`)\n                            .join('');\n                        return Object.assign(Object.assign({}, t), { isRichText: true, content: htmlContent || '<p></p>' // Ensure there's at least an empty paragraph\n                         });\n                    }\n                    return t;\n                });\n                chrome.storage.sync.set({ [STORAGE_KEY]: migratedTemplates }, () => {\n                    console.log('Templates migrated to rich text format');\n                });\n            }\n        });\n    }\n});\n// Listen for context menu clicks\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    if (message.action === 'OPEN_TEMPLATE_MANAGER') {\n        // Open the template manager popup\n        chrome.action.openPopup();\n    }\n    return true;\n});\n"],"names":[],"sourceRoot":""}