{"version":3,"file":"background.js","mappings":";;;;;;;;;;;;;;;;;AAAA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACO;AACA;AACA;AACP;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA,sCAAsC,0BAA0B;AAChE;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mBAAmB,sBAAsB,cAAc;AACpG;AACA,0DAA0D,eAAe,+DAA+D;AACxI;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,UAAU,sBAAsB,kBAAkB;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,kBAAkB,sBAAsB,sBAAsB;AAC/G;AACA;AACA,4EAA4E,iCAAiC,uBAAuB;AACpI;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA,iEAAiE,mBAAmB,qHAAqH;AACzM;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,sCAAsC,mCAAmC;AACzE;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,KAAK;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,sGAAsG,eAAe,wCAAwC;AAC7J;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,eAAe,qBAAqB;AACzF;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA,iEAAe,cAAc,EAAC;;;;;;;UC3N9B;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;ACNA;AACiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,cAAc,wGAAwG,aAAa,kEAAkE,eAAe,2BAA2B,WAAW,IAAI,WAAW;AACxS;AACA,sBAAsB,yEAAyE;AAC/F,sBAAsB,+EAA+E;AACrG,sBAAsB,iFAAiF;AACvG,sBAAsB,+DAA+D;AACrF,sBAAsB,sEAAsE;AAC5F;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,kCAAkC,cAAc,uDAAuD,SAAS,qKAAqK,cAAc,yEAAyE,qBAAqB,0HAA0H,WAAW,IAAI,aAAa;AACvhB;AACA,sBAAsB,yEAAyE;AAC/F,sBAAsB,sEAAsE;AAC5F,sBAAsB,+EAA+E;AACrG,sBAAsB,uIAAuI;AAC7J,sBAAsB,+DAA+D;AACrF,sBAAsB;AACtB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,+BAA+B,cAAc,sEAAsE,kBAAkB,uQAAuQ,WAAW,IAAI,WAAW;AACta;AACA,sBAAsB,yEAAyE;AAC/F,sBAAsB,2FAA2F;AACjH,sBAAsB,+DAA+D;AACrF,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,kCAAkC,CAAC,0DAAW,qBAAqB;AACnE;AACA,SAAS;AACT;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","sources":["webpack://support-template-manager/./src/services/storage.ts","webpack://support-template-manager/webpack/bootstrap","webpack://support-template-manager/webpack/runtime/define property getters","webpack://support-template-manager/webpack/runtime/hasOwnProperty shorthand","webpack://support-template-manager/webpack/runtime/make namespace object","webpack://support-template-manager/./src/background.ts"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nexport const STORAGE_KEY = 'support_templates';\nexport const GLOBAL_VARIABLES_KEY = 'support_global_variables';\nexport const storageService = {\n    // Get all templates\n    getTemplates: () => {\n        return new Promise((resolve) => {\n            chrome.storage.sync.get(STORAGE_KEY, (result) => {\n                resolve(result[STORAGE_KEY] || []);\n            });\n        });\n    },\n    // Get template groups (templates organized by baseId)\n    getTemplateGroups: () => __awaiter(void 0, void 0, void 0, function* () {\n        const templates = yield storageService.getTemplates();\n        const groupsMap = {};\n        // Group templates by baseId\n        templates.forEach(template => {\n            const baseId = template.baseId || template.id;\n            if (!groupsMap[baseId]) {\n                groupsMap[baseId] = {\n                    baseId,\n                    name: template.name,\n                    category: template.category,\n                    templates: {\n                        'EN': null,\n                        'FR': null,\n                        'DE': null\n                    },\n                    variables: template.variables\n                };\n            }\n            // Add the template to its language slot\n            const language = template.language || 'EN';\n            groupsMap[baseId].templates[language] = template;\n        });\n        return Object.values(groupsMap);\n    }),\n    // Save templates\n    saveTemplates: (templates) => {\n        return new Promise((resolve) => {\n            chrome.storage.sync.set({ [STORAGE_KEY]: templates }, () => {\n                resolve();\n            });\n        });\n    },\n    // Add new template\n    addTemplate: (template) => __awaiter(void 0, void 0, void 0, function* () {\n        const templates = yield storageService.getTemplates();\n        const timestamp = Date.now();\n        const newId = crypto.randomUUID();\n        // Check if this is a new template or a translation\n        // We'll determine if it's a translation by checking if a template with the same name already exists\n        const existingTemplate = templates.find(t => t.name === template.name);\n        const baseId = existingTemplate ? existingTemplate.baseId : newId;\n        // Check if a template with this language already exists\n        const duplicateLanguage = templates.find(t => t.baseId === baseId &&\n            t.language === template.language);\n        if (duplicateLanguage) {\n            throw new Error(`A template in ${template.language} already exists for \"${template.name}\"`);\n        }\n        const newTemplate = Object.assign(Object.assign({}, template), { id: newId, baseId, createdAt: timestamp, updatedAt: timestamp });\n        yield storageService.saveTemplates([...templates, newTemplate]);\n        return newTemplate;\n    }),\n    // Add a translation to an existing template\n    addTranslation: (baseTemplate, language, content) => __awaiter(void 0, void 0, void 0, function* () {\n        const templates = yield storageService.getTemplates();\n        const timestamp = Date.now();\n        // Check if a translation in this language already exists\n        const existingTranslation = templates.find(t => t.baseId === baseTemplate.baseId &&\n            t.language === language);\n        if (existingTranslation) {\n            throw new Error(`A translation in ${language} already exists for \"${baseTemplate.name}\"`);\n        }\n        const newTranslation = {\n            id: crypto.randomUUID(),\n            baseId: baseTemplate.baseId,\n            name: baseTemplate.name,\n            category: baseTemplate.category,\n            content,\n            variables: baseTemplate.variables,\n            language,\n            createdAt: timestamp,\n            updatedAt: timestamp\n        };\n        yield storageService.saveTemplates([...templates, newTranslation]);\n        return newTranslation;\n    }),\n    // Update existing template\n    updateTemplate: (id, updates) => __awaiter(void 0, void 0, void 0, function* () {\n        const templates = yield storageService.getTemplates();\n        const index = templates.findIndex(t => t.id === id);\n        if (index === -1)\n            return null;\n        const templateToUpdate = templates[index];\n        // If changing the language, check if there's already a template in that language\n        if (updates.language && updates.language !== templateToUpdate.language) {\n            const duplicateLanguage = templates.find(t => t.baseId === templateToUpdate.baseId &&\n                t.language === updates.language &&\n                t.id !== id);\n            if (duplicateLanguage) {\n                throw new Error(`A template in ${updates.language} already exists for \"${templateToUpdate.name}\"`);\n            }\n        }\n        const updatedTemplate = Object.assign(Object.assign(Object.assign({}, templateToUpdate), updates), { updatedAt: Date.now() });\n        templates[index] = updatedTemplate;\n        // If name or category is updated, update all templates with the same baseId\n        if (updates.name || updates.category) {\n            for (let i = 0; i < templates.length; i++) {\n                if (templates[i].baseId === templateToUpdate.baseId && i !== index) {\n                    templates[i] = Object.assign(Object.assign({}, templates[i]), { name: updates.name || templates[i].name, category: updates.category || templates[i].category, updatedAt: Date.now() });\n                }\n            }\n        }\n        yield storageService.saveTemplates(templates);\n        return updatedTemplate;\n    }),\n    // Delete template\n    deleteTemplate: (id) => __awaiter(void 0, void 0, void 0, function* () {\n        const templates = yield storageService.getTemplates();\n        const filteredTemplates = templates.filter(t => t.id !== id);\n        if (filteredTemplates.length === templates.length)\n            return false;\n        yield storageService.saveTemplates(filteredTemplates);\n        return true;\n    }),\n    // Delete all templates with the same baseId\n    deleteTemplateGroup: (baseId) => __awaiter(void 0, void 0, void 0, function* () {\n        const templates = yield storageService.getTemplates();\n        const filteredTemplates = templates.filter(t => t.baseId !== baseId);\n        if (filteredTemplates.length === templates.length)\n            return false;\n        yield storageService.saveTemplates(filteredTemplates);\n        return true;\n    }),\n    // Get global variables\n    getGlobalVariables: () => {\n        return new Promise((resolve) => {\n            chrome.storage.sync.get(GLOBAL_VARIABLES_KEY, (result) => {\n                resolve(result[GLOBAL_VARIABLES_KEY] || []);\n            });\n        });\n    },\n    // Save global variables\n    saveGlobalVariables: (variables) => {\n        return new Promise((resolve) => {\n            chrome.storage.sync.set({ [GLOBAL_VARIABLES_KEY]: variables }, () => {\n                resolve();\n            });\n        });\n    },\n    // Update a global variable\n    updateGlobalVariable: (name, updates) => __awaiter(void 0, void 0, void 0, function* () {\n        const variables = yield storageService.getGlobalVariables();\n        const index = variables.findIndex(v => v.name === name);\n        if (index === -1) {\n            // If variable doesn't exist, add it\n            const newVariable = {\n                name,\n                description: updates.description || `Value for ${name}`,\n                defaultValue: updates.defaultValue || ''\n            };\n            yield storageService.saveGlobalVariables([...variables, newVariable]);\n            return newVariable;\n        }\n        // Update existing variable\n        const updatedVariable = Object.assign(Object.assign({}, variables[index]), updates);\n        variables[index] = updatedVariable;\n        yield storageService.saveGlobalVariables(variables);\n        return updatedVariable;\n    }),\n    // Export all data (templates and global variables)\n    exportData: () => __awaiter(void 0, void 0, void 0, function* () {\n        const [templates, globalVariables] = yield Promise.all([\n            storageService.getTemplates(),\n            storageService.getGlobalVariables()\n        ]);\n        return {\n            templates,\n            globalVariables\n        };\n    }),\n    // Import data (templates and global variables)\n    importData: (data) => __awaiter(void 0, void 0, void 0, function* () {\n        if (data.templates) {\n            // Make sure all templates have a baseId (for backwards compatibility)\n            const templatesWithBaseId = data.templates.map(template => (Object.assign(Object.assign({}, template), { baseId: template.baseId || template.id })));\n            yield storageService.saveTemplates(templatesWithBaseId);\n        }\n        if (data.globalVariables) {\n            yield storageService.saveGlobalVariables(data.globalVariables);\n        }\n    }),\n    // Migrate existing templates to the new structure with baseId\n    migrateTemplates: () => __awaiter(void 0, void 0, void 0, function* () {\n        const templates = yield storageService.getTemplates();\n        let needsMigration = false;\n        // Check if any template is missing a baseId\n        const migratedTemplates = templates.map(template => {\n            if (!template.baseId) {\n                needsMigration = true;\n                return Object.assign(Object.assign({}, template), { baseId: template.id });\n            }\n            return template;\n        });\n        if (needsMigration) {\n            yield storageService.saveTemplates(migratedTemplates);\n        }\n    })\n};\nexport default storageService;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// Background script for our Chrome extension\nimport { STORAGE_KEY } from './services/storage';\n// Listen for installation\nchrome.runtime.onInstalled.addListener((details) => {\n    if (details.reason === 'install') {\n        // Set up initial template examples\n        const initialTemplates = [\n            {\n                id: crypto.randomUUID(),\n                baseId: crypto.randomUUID(), // Add baseId (will be the same as id for first template)\n                name: 'Welcome Response',\n                category: 'General',\n                content: 'Hi {{customerName}},\\n\\nThank you for reaching out to our support team! We\\'re happy to help you with your inquiry about {{productName}}.\\n\\nI\\'ll look into this right away and get back to you within {{responseTime}} hours.\\n\\nBest regards,\\n{{agentName}}\\n{{teamName}} Support',\n                variables: [\n                    { name: 'customerName', description: 'Customer\\'s name', defaultValue: '' },\n                    { name: 'productName', description: 'Product name', defaultValue: 'our product' },\n                    { name: 'responseTime', description: 'Response time in hours', defaultValue: '24' },\n                    { name: 'agentName', description: 'Your name', defaultValue: '' },\n                    { name: 'teamName', description: 'Team name', defaultValue: 'Customer' },\n                ],\n                language: 'EN', // Add language property\n                createdAt: Date.now(),\n                updatedAt: Date.now()\n            },\n            {\n                id: crypto.randomUUID(),\n                baseId: crypto.randomUUID(), // Add baseId (will be the same as id for first template)\n                name: 'Technical Issue Response',\n                category: 'Technical',\n                content: 'Hello {{customerName}},\\n\\nI understand you\\'re experiencing an issue with {{feature}}. I apologize for any inconvenience this has caused.\\n\\nTo help troubleshoot this issue, could you please provide the following information:\\n\\n1. What version of {{productName}} are you currently using?\\n2. When did you first notice this issue?\\n3. {{additionalQuestions}}\\n\\nOnce I have this information, I\\'ll be better equipped to help resolve your issue.\\n\\nThank you for your patience,\\n{{agentName}}\\n{{department}} Support Team',\n                variables: [\n                    { name: 'customerName', description: 'Customer\\'s name', defaultValue: '' },\n                    { name: 'feature', description: 'Feature with issue', defaultValue: '' },\n                    { name: 'productName', description: 'Product name', defaultValue: 'our product' },\n                    { name: 'additionalQuestions', description: 'Any additional questions', defaultValue: 'Have you tried clearing your cache and cookies?' },\n                    { name: 'agentName', description: 'Your name', defaultValue: '' },\n                    { name: 'department', description: 'Your department', defaultValue: 'Technical' }\n                ],\n                language: 'EN', // Add language property\n                createdAt: Date.now(),\n                updatedAt: Date.now()\n            },\n            {\n                id: crypto.randomUUID(),\n                baseId: crypto.randomUUID(), // Add baseId (will be the same as id for first template)\n                name: 'Follow-up Template',\n                category: 'General',\n                content: 'Hi {{customerName}},\\n\\nI wanted to follow up on your recent support request regarding {{issueDescription}}.\\n\\nHas the solution we provided resolved your issue? If you\\'re still experiencing problems or have any questions, please don\\'t hesitate to let me know.\\n\\nYour feedback is important to us as we strive to provide the best possible support.\\n\\nBest regards,\\n{{agentName}}\\n{{teamName}} Support',\n                variables: [\n                    { name: 'customerName', description: 'Customer\\'s name', defaultValue: '' },\n                    { name: 'issueDescription', description: 'Brief description of the issue', defaultValue: '' },\n                    { name: 'agentName', description: 'Your name', defaultValue: '' },\n                    { name: 'teamName', description: 'Team name', defaultValue: 'Customer' }\n                ],\n                language: 'EN', // Add language property\n                createdAt: Date.now(),\n                updatedAt: Date.now()\n            }\n        ];\n        // For each template, set the baseId to be the same as the id initially\n        initialTemplates.forEach(template => {\n            template.baseId = template.id;\n        });\n        // Save initial templates to storage\n        chrome.storage.sync.set({ [STORAGE_KEY]: initialTemplates }, () => {\n            console.log('Initial templates created');\n        });\n    }\n});\n// Listen for context menu clicks\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    if (message.action === 'OPEN_TEMPLATE_MANAGER') {\n        // Open the template manager popup\n        chrome.action.openPopup();\n    }\n    return true;\n});\n"],"names":[],"sourceRoot":""}